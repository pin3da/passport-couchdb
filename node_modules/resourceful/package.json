{
  "name": "resourceful",
  "description": "A storage agnostic resource-oriented ODM for building prototypical models with validation and sanitization.",
  "version": "0.2.3",
  "url": "http://github.com/flatiron/resourceful",
  "keywords": [
    "ODM",
    "database",
    "couchdb",
    "model",
    "resource"
  ],
  "author": {
    "name": "Nodejitsu Inc.",
    "email": "info@nodejitsu.com"
  },
  "maintainers": [
    {
      "name": "indexzero",
      "email": "charlie@nodejitsu.com"
    },
    {
      "name": "indutny",
      "email": "fedor.indutny@gmail.com"
    }
  ],
  "repository": {
    "type": "git",
    "url": "git://github.com/flatiron/resourceful.git"
  },
  "dependencies": {
    "cradle": "0.6.x",
    "i": "0.3.x",
    "revalidator": "0.1.x"
  },
  "devDependencies": {
    "vows": "~0.6.0"
  },
  "main": "./lib/resourceful",
  "engines": {
    "node": ">= 0.6.0"
  },
  "scripts": {
    "browserify": "browserify lib/browser.js -o build/resourceful.js",
    "test": "vows --spec -i"
  },
  "readme": "\n<img src=\"https://github.com/flatiron/resourceful/raw/master/resourceful.png\" />\n\n# Synopsis\nA storage agnostic resource-oriented ODM for building prototypical models with validation and sanitization.\n\n# Motivation\nHow often have you found yourself writing Model code in your application? Pretty often? Good! Unlike other \"Object-Document Mappers\" `resourceful` tries to only focus on two things:\n\n - A simple API for defining custom Model prototypes with validation. No sugar is required to instantiate prototypes defined by resourceful.\n\n - Define an extensibility model for databases to provide CRUD functionality to Models along with custom query, filtering or updating specific to that specific implementation (Mongo, CouchDB, Redis, etc).\n\n# Status\n\n[![Build Status](https://secure.travis-ci.org/flatiron/resourceful.png)](http://travis-ci.org/flatiron/resourceful)\n\n# Features\n* Data Validation\n* Simplified Data Model Management\n* [Storage Engine Extensible](#engines)\n* [Simplified Cache Control](#cache)\n\n# Installation\n\n``` bash \n$ [sudo] npm install resourceful\n```\n\n# Usage\n\n## Simple case\n\n``` js\nvar resourceful = require('resourceful');\n\nvar Creature = resourceful.define('creature', function () {\n  //\n  // Specify a storage engine\n  //\n  this.use('couchdb');\n  \n  //\n  // Specify some properties with validation\n  //\n  this.string('diet');\n  this.bool('vertebrate');\n  this.array('belly');\n\n  //\n  // Specify timestamp properties\n  //\n  this.timestamps();\n});\n\n//\n// Now that the `Creature` prototype is defined\n// we can add custom logic to be available on all instances\n//\nCreature.prototype.feed = function (food) {\n  this.belly.push(food);\n};\n```\n\n## Defining resources\nHere's the simplest of resources:\n\n``` js\nvar Creature = resourceful.define('creature');\n```\n\nThe returned `Creature` object is a *resource constructor*, in other words, a *function*. Now let's add some properties to this constructor:\n\n``` js\nCreature.string('diet');\nCreature.bool('vertebrate');\nCreature.array('belly');\nCreature.object('children');\n\n// Are equivalent to\nCreature.property('diet'); // Defaults to String\nCreature.property('vertebrate', Boolean);\nCreature.property('belly', Array);\nCreature.property('children', Object);\n```\n\nAnd add a method to the prototype:\n\n``` js\nCreature.prototype.feed = function (food) {\n  this.belly.push(food);\n};\n```\n\nNow lets instantiate a Creature, and feed it:\n\n``` js\nvar wolf = new(Creature)({\n  diet:      'carnivore',\n  vertebrate: true\n});\n\nwolf.feed('squirrel');\nconsole.dir(wolf.belly);\n```\n\nYou can also define resources this way:\n\n``` js\nvar Creature = resourceful.define('creature', function () {\n  this.string('diet');\n  this.bool('vertebrate');\n  this.array('belly');\n\n  this.prototype.feed = function (food) {\n    this.belly.push(food);\n  };\n});\n```\n\n## Defining properties with Resource.property\nLets define a *legs* property, which is the number of legs the creature has:\n\n``` js\nCreature.number('legs');\n```\n\nNote that this form is equivalent:\n\n``` js\nCreature.property('legs', Number);\n/* or */\nCreature.property('legs', 'number');\n```\n\nIf we wanted to constrain the possible values the property could take, we could pass in an object as the last parameter:\n\n``` js\nCreature.number('legs', {\n  required: true,\n\n  minimum: 0,\n  maximum: 8,\n\n  conform: function (val) {\n    return val % 2 === 0;\n  }\n});\n```\n\nNow resourceful won't let `Creature` instances be saved unless the *legs* property has a value between `0` and `8`, and is *even*,\n\nThis style is also valid for defining properties:\n\n``` js\nCreature.number('legs')\n        .required()\n        .minimum(0)\n        .maximum(8)\n        .conform(function (val) { return val % 2 === 0 });\n```\n\nIf we want to access and modify an already defined property, we can do it this way:\n\n``` js\nCreature.schema.properties['legs'].maximum(6);\n```\n\n<a name=\"engines\"></a>\n## Engines (saving and fetching resources)\nBy default, resourceful uses an in-memory engine. If we would like our resources to be persistent, we must use another engine, for example CouchDB.\n\nEngines are used for exposing different storage backends to resourceful. Resourceful currently has two bundled engines:\n\n* couchdb\n* memory\n\nEngines can be specified when defining a resource with `this.use`:\n\n```js\nvar Creature = resource.define('creature', function () {\n  \n  this.use('couchdb', {\n    uri: 'http://example.jesusabdullah.net'\n  });\n\n  /*\n  \n      //\n      // alternately\n      //\n      this.use('memory');\n\n      //\n      // or, supposing `Engine` is defined as a resourceful engine:\n      //\n      this.use(Engine, {\n        'uri': 'file:///tmp/datastore'\n      });\n\n  */\n\n});\n```\n\n## Using the CouchDB engine\nFirst, one must create a CouchDB database for resourceful to use. One way to do this is to use Futon, located by default at [http://localhost:5984/_utils/](http://localhost:5984/_utils/). In this example, we name the database **myResourcefulDB**.\n\nNext, let resourceful know to use use this particular CouchDB database.\n\n``` js\nvar resourceful = require('resourceful');\n\nresourceful.use('couchdb', {database: 'myResourcefulDB'});\n```\n\n## Saving and fetching resources (engine agnostic)\nAssuming we have already defined a ''Wolf'' resource with name, age, and fur properties, we can fetch and save wolf resources like this:\n\n``` js\nWolf.create({ name: 'Wolverine', age: 68 }, function (err, wolf) {\n  if (err) { throw new(Error)(err) }\n\n  console.log(wolf); // { _id: 42, resource: 'wolf', name: 'Wolverine', age: 68 }\n\n  wolf.age++;\n  wolf.save(function (err) {\n    if (!err) {\n      console.log('happy birthday ' + wolf.name + '!');\n    }\n  });\n});\n\nWolf.get(42, function (err, wolf) {\n  if (err) { throw new(Error)(err) }\n\n  wolf.update({ fur: 'curly' }, function (e, wolf) {\n    console.log(wolf.fur); // \"curly\"\n  });\n});\n```\n\n<a name=\"cache\"></a>\n## Engine caching\nResourceful comes with a helper for managing an in-memory cache of your documents. This helps increase the speed of resourceful by avoiding extraneous interactions with the back-end.\n\nUnlike engines, caches have a completely synchronous API. This is acceptable since the calls are short and usually occur inside an asynchronously-executing procedure.\n\n## History\nResourceful's first engine was the couchdb engine, which was built using cradle. As such, the design of resourceful's engines is somewhat inferred from the design of couchdb itself. In particular, engine prototypes are often named and designed after http verbs, status reporting follows http status code conventions, and engines can be designed around stored views.\n\nThat said: The memory engine, as it needs to do much less, can be considered to have the most minimal api possible for an engine, with a few exceptions.\n\nBoth pieces of code are more-or-less self-documenting.\n\n# API\n\n## Resource Constructor\nThese methods are available on all user-defined resource constructors, as well as on the default `resourceful.Resource` constructor.\n\n* `Resource.get(id, [callback])`: Fetch a resource by *id*.\n* `Resource.update(id, properties, [callback])`: Update a resource with properties.\n* `Resource.destroy(id, [callback])`: Destroy a resource by *id*.\n* `Resource.all([callback])`: Fetches all resources of this type.\n* `Resource.find(properties, [callback])`: Find all resources of this type which satisfy `obj` conditions\n* `Resource.save(inst, [callback])`: Saves the specified resource instance `inst` by overwriting all properties. \n* `Resource.create(properties, [callback])`: Creates a new instance of the Resource with the specified `properties`\n* `Resource.new(properties)`: Instantiates a new instance of the Resource with the `properties`\n\n## Resource Instance Methods\n\n* `Resource.prototype.save([callback])`\n* `Resource.prototype.update(properties, [callback])`\n* `Resource.prototype.destroy([callback])`\n* `Resource.prototype.reload([callback])`\n\n## Engine Constructor\nIn general, it is safe to attach instance methods to your new engine. For example, `memory.js` keeps a counter (called `this.counter`) for creating new documents without a specified name.\n\n```js\nvar engine = new Engine({\n  uri: 'protocol://path/to/database'\n});\n```\n\nAt a minimum, the constructor should:\n\n### Interpret the 'uri' argument\nThe 'uri' argument should be treated as a unique ID to your particular data store. For example, this is a couchdb uri for the couchdb store.\n\nIn most cases the uri argument will correspond to a database url, but that's not always true. In the case of \"memory\", it's simply a legal javascript object property name.\n\n### Initialize a store\nA constructed engine should, in some way or another, initialize a connection to its data store. For couchdb, this means opening a new connection object with cradle and attaching it as `this.connection`. However, this isn't a good fit for all cases; the memory store, for example, simply creates a new property to a \"stores\" object if `stores[\"storeName\"]` doesn't exist.\n\n## Engine Instance Members\n\n### protocol\nResourceful will parse out the \"couchdb\" from the protocol and attempt to use an included resource with that string as its `resource.protocol`.\n\nFor third-party engines this may not seem critical but it's good practice to include anyway, for the purposes of inspection if nothing else.\n\n```js\nEngine.prototype.protocol = 'file';\n```\n\nThe protocol method sets the protocol member is used by resourceful to add syntactic sugar such that you may do:\n\n```js\nResource.connect('couchdb://example.nodejitsu.com');\n```\n\n## Engine Instance Methods\nResourceful allows flexibility in some prototype methods, but not in others. Authors are encouraged to add prototype methods that feel natural to expose; for instance, the couchdb engine exposes `this.prototype.head` for sending http HEAD requests.\n\n### request()\nUnlike some of the other prototype methods, `request` does not have to follow any particular contract, as it's used by your engine internally to encapsulate an asynchronous request to your particular datastore.\n\n```js\nthis.request(function () {\n\n  var update = key in this.store;\n  this.store[key] = val;\n  callback(null, resourceful.mixin({ status: update ? 200 : 201 }, val));\n});\n```\n\nIn the case of the memory datastore, this simply involves a process.nextTick helper:\n\n```js\nMemory.prototype.request = function (fn) {\n\n  var self = this;\n\n  process.nextTick(function () {\n    fn.call(self);\n  });\n};\n```\n\nIn the couchdb engine, requests look more like:\n\n```\nthis.request('post', doc, function (e, res) {\n\n  if (e) {\n    return callback(e);\n  }\n\n  res.status = 201;\n  callback(null, resourceful.mixin({}, doc, res));\n});\n```\n\nAn engine should expose the request interface that feels most natural given the transport. However, there are some conventions to follow:\n\n1. `this.request` should be asynchronous.\n2. The callback should set 'this' to be the same context as outside the callback\n\n### save()\nBecause the engines api was written with couchdb in mind, 'doc' should include an appropriate http status under `doc.status`. \n\n`save` can be implemented using a combination of 'head', 'put' and 'post', as in the case of the couchdb engine. However, in the memory engine case `put` is an alias to `save` and `update` is implemented separately. See below: **head**, **put** and **update**. The following pattern should be followed across all engines:\n\n```js\nengine.save('key', value, function (err, doc) {\n\n  if (err) {\n    throw err;\n  }\n\n  if (doc.status == 201) {\n    // Will be 201 instead of 200 if the document is created instead of modified\n    console.log('New document created!');\n  }\n\n  console.log(doc);\n});\n```\n\n### put()\n`put` is typically used to represent operations that update or modify the database without creating new resources. However, it is acceptable to alias the 'save' method and allow for the creation of new resources.\n\nBecause the engines api was written with couchdb in mind, 'doc' should include an appropriate http status under `doc.status`. The expected status is '201'. See below: **post**. This pattern should be followed across all engines:\n\n```js\nengine.put('key', value, function (err, doc) {\n\n  if (err) {\n    throw err;\n  }\n\n  if (doc.status === 201) {\n    console.log('Document updated!');\n  }\n  else {\n    throw new Error('Document did not update.');\n  }\n\n  console.log(doc);\n});\n```\n\n### post()\n### create()\nThis pattern should be followed across all engines for implementations of these methods. However, they are *optional*. The memory engine defines `Engine.prototype.load` instead. For instance:\n\n```js\nengine.create('key', value, function (err, doc) {\n\n  if (err) {\n    throw err;\n  }\n\n  if (doc.status === 201) {\n    console.log('Document updated!');\n  }\n  else {\n    throw new Error('Status: '+doc.status);\n  }\n\n  console.log(doc);\n});\n```\n\n`post` is typically used to represent operations that create new resources without modifying or updating existing ones. `create` should be implemented as an alias for `post`.\n\nBecause the engines api was written with couchdb in mind, 'doc' should include an appropriate http status under `doc.status`. The expected status is '201'.\n\n### load()\nThis method is *optional* and is used to more or less replace the \"create\" and \"post\" methods along with \"put\" and \"save\".\n\n```js\n//\n// Example with the memory transport\n//\nvar memory = new Memory();\n\nmemory.load([ { 'foo': 'bar' }, { 'bar': 'baz' }]);\n```\n\nIn the above example, each object passed to memory.load is loaded as a new document. This approach is useful in cases where you already have a javascript representation of your store (as in the case of memory) and don't need to interact with a remote api as in the case of couchdb.\n\n### update()\n`update` is used to modify existing resources by copying enumerable properties from the update object to the existing object (often called a \"mixin\" and implemented in javascript in `resourceful.mixin` and `utile.mixin`). Besides the mixin process (meaning your stored object won't lose existing properties), `update` is synonymous with `put`, and in fact uses `put` internally in the case of both the couchdb and memory engines.\n\nBecause the engines api was written with couchdb in mind, 'doc' should include an appropriate http status under `doc.status`. The expected status is '201', as with `put`. This pattern should be followed across all engines:\n\n```js\nengine.put('key', { 'foo': 'bar' }, function (err, doc) {\n\n  if (err) {\n    throw err;\n  }\n\n  if (doc.status === 201) {\n    console.log('Document updated!');\n  }\n  else {\n    throw new Error('Document did not update.');\n  }\n\n  console.log(doc); // doc.foo should now be bar\n\n});\n```\n\n### get()\nThis pattern should be followed across all engines:\n\n```js\nengine.get('key', function (err, doc) {\n\n  if (err) {\n    if (err.status === 404) {\n      console.log('Document was not there!');\n    }\n\n    throw err;\n  }\n\n  console.log(doc);\n});\n```\n\n### destroy()\n`destroy` is used to delete existing resources. \n\nBecause the engines api was written with couchdb in mind, 'doc' should include an appropriate http status under `doc.status`. The expected status is '204', which stands for 'successfully deleted'. This pattern should be followed across all engines:\n\n```js\nengine.get('key', function (err, doc) {\n\n  if (err) {\n    throw err;\n  }\n\n  //\n  // \"status\" should be the only property on `doc`.\n  //\n  if (doc.status !== 204) {\n    throw new Error('Status: '+doc.status);\n  }\n\n  console.log('Successfully destroyed document.');\n});\n```\n\n### find()\n`find` is a shorthand for finding resources which in some cases can be implemented as a special case of `filter`, as with memory here:\n\n```js\nMemory.prototype.find = function (conditions, callback) {\n\n  this.filter(function (obj) {\n    return Object.keys(conditions).every(function (k) {\n      return conditions[k] ===  obj[k];\n    });\n  }, callback);\n};\n```\n\nThis pattern should be followed across all engines:\n\n```js\nengine.find({ 'foo': 'bar' }, function (err, docs) {\n\n  if (err) {\n    throw err;\n  }\n\n  //\n  // docs[0].foo === 'bar'\n  //\n\n});\n```\n\nThe couchdb version, however, uses special logic as couchdb uses temporary and stored views.\n\n```\n\n  IMPORTANT NOTE\n  --------------\n\n  `CouchDB.prototype.find` uses a temporary view. This is useful while testing but is slow and bad practice on a production couch. Please use `CouchDB.prototype.filter` instead.\n\n```\n\n### filter()\nThe semantics of 'filter' vary slightly depending on the engine. The semantics of `filter()`, like those of `request()`, should reflect the particular idioms of the underlying transport.\n\n```js\n//\n// Example used with a Memory engine\n//\nengine.filter(filterfxn, function (err, docs) {\n\n  if (err) {\n    throw err;\n  }\n\n  //\n  // returned docs filtered by \"filter\"\n  //\n\n});\n```\n\nThe \"memory\" case simply applies a function against the store's documents. In contrast, the couchdb engine exposes an api for using stored mapreduce functions on the couch:\n\n```js\n//\n// Example used with a Couchdb engine\n//\nengine.filter(\"view\", params, function (err, docs) {\n\n  if (err) {\n    throw err;\n  }\n\n  //\n  // returned docs filtered using the \"view\" mapreduce function on couch.\n  //\n\n});\n```\n\n### sync()\n`Engine.prototype.sync` is used to sync \"design document\" information with the database if necessary. This is specific to couchdb; for the 'memory' transport there is no conception of (or parallel to) a design document.\n\n```js\nengine.sync(factory, function (err) {\n\n  if (err) {\n    throw err;\n  }\n});\n```\n\nIn the case where there is no doc or \"stored procedures\" of any kind to upload to the database, this step can be simplified to:\n\n```js\nEngine.prototype.sync = function (factory, callback) {\n\n  process.nextTick(function () { callback(); });\n};\n```\n\n## Cache Constructor\nThis creates a new in-memory cache for your engine. The cache is automatically populated by resourceful. This means that you don't need to actually use the cache directly for many operations. In fact, the memory engine doesn't explicitly use resourceful.Cache at all.\n\n```js\nvar resourceful = require('resourceful');\n\nvar cache = new Cache();\n```\n\n## Cache Instance Methods\n`resourceful.Cache` has the following prototypes for interacting with the in-memory cache:\n\n* `Cache.prototype.get(id)`: Attempt to 'get' a cached document.\n* `Cache.prototype.put(id, doc)`: Attempt to 'put' a document into the cache.\n* `Cache.prototype.update(id, doc)`: Attempt to update a document in the cache. *This means that it will attempt to merge your old and new document instead of overwriting the old with the new!*\n* `Cache.prototype.clear(id)`: Attempts to remove a document from the cache. Document 'overwriting' may be achieved with call to `.clear` followed by a call to `.put`.\n* `Cache.prototype.has(id)`: Checks to see if a given document is in the cache or not.\n\nThe couchdb engine explicity uses resourceful.Cache in two places, both in cases where fetching the document is prohibitive and can be avoided. The couchdb engine checks the cache for the object with which to merge new data before uploading:\n\n```js\nCouchdb.prototype.update = function (id, doc, callback) {\n\n  return this.cache.has(id) \n    ? this.put(id, resourceful.mixin({}, this.cache.get(id).toJSON(), doc), callback)\n    : this.request('merge', id, doc, callback);\n};\n```\n\n`object.toJSON` is a misnomer; Instead of returning json, `.toJSON()` returns a cloned object. This method is named as such because it's [detected and used by JSON.stringify](https://developer.mozilla.org/en/JSON#toJSON\\(\\)_method).\n\nThe couchdb engine checks the cache for the object it wants to destroy:\n\n```js\nif (this.cache.has(id)) {\n\n  args.splice(1, -1, this.cache.get(id)._rev);\n  return this.request.apply(this, ['remove'].concat(args));\n}\n```\n\nIn the above snippet (just a small part of the entire function), the couchdb engine uses the cache to get revision data without doing a GET.\n\n# Tests\nAll tests are written with [vows][0] and should be run with [npm][1]:\n\n```bash\n  $ npm test\n```\n\n[0]: http://vowsjs.org\n[1]: http://npmjs.org\n\n# License\nCopyright 2012 Nodejitsu, Inc.\n\nLicensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at\n\n  http://www.apache.org/licenses/LICENSE-2.0\n\nUnless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.\n\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/flatiron/resourceful/issues"
  },
  "homepage": "https://github.com/flatiron/resourceful",
  "_id": "resourceful@0.2.3",
  "_from": "resourceful@"
}
